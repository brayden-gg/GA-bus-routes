<!DOCTYPE html>
<html>

<head>
    <script src="../Libraries/p5.min.js"></script>
    <title>Proposed MBTA Map</title>
    <style>
        .line-button {
            color: white;
            font-size: 15px;
            margin: 5px;
            font-family: "Helvetica Neue", "Arial";
            width: 230px;

        }

        .title {
            font-family: "Raleway", "helvetica Neue", "Arial";
        }



        canvas {
            background-image: url("mapBG.jpg");
            background-repeat: no-repeat;
            background-position-x: -83px;
            background-position-y: -210px;
            background-size: 930px 1275px;
        }
    </style>
</head>

<body>
    <script src="../Data/riderData.js"></script>
    <script src="../Data/precalculatedDistances.js"></script>


    <script src="../Data/originalRoutes.js"></script>
    <script src="../Generated Systems/initializedOriginalRoutes.js"></script>
    <script src="../Generated Systems/initializedRandomRoutes.js"></script>
    <script src="../Generated Systems/misleadingRoutes.js"></script>


    <script>
        let mapOptions = {
            "MBTA Bus System": {
                routes: original,
                description: "The bus system currently in use by the MBTA."
            },
            "Generated from Scratch": {
                routes: initializedRandomRoutes,
                description: "The bus system generated by the algorithm from scratch."
            },
            "Generated from Baseline": {
                routes: initializedOriginalRoutes,
                description: "The bus system generated using the current system as a baseline and improving from there."
            }
        }

        let routes = original;
        let currentRoutesName = Object.keys(mapOptions)[0]
        let currentLine = -1;

        let toggled = [];
        let graph = {};
        let colors = [
            [255, 51, 51], //light red
            [255, 153, 51], //orange
            [255, 255, 51], //yellow
            [153, 255, 51], //lime
            [51, 255, 51], //green
            [51, 255, 153], //lighter
            [51, 153, 255], //blue
            [51, 51, 255], //darker blue
            [153, 51, 255], //purple
            [255, 51, 255], //light pink
            [153, 0, 0], //dark red
        ];

        graph.left = data.reduce((min, p) => p.x < min ? p.x : min, data[0].x); //set boundaries for the displaying of the map
        graph.right = data.reduce((max, p) => p.x > max ? p.x : max, data[0].x);
        graph.lower = data.reduce((min, p) => p.y < min ? p.y : min, data[0].y);
        graph.upper = data.reduce((max, p) => p.y > max ? p.y : max, data[0].y);

        let info;
        let buttons = [];
        let dropDown;
        let container;

        let backgroundImg;

        function setup() {
            createCanvas(800, 800);
            container = createDiv()
                .position(850, 50);
            container.elt.style.width = "240px";

            buttons[0] = createButton("View all")
                .parent(container)
                .addClass("line-button")
                .mouseClicked(() => clickButton(-1));

            buttons[0].elt.style.backgroundColor = "black";
            buttons[0].elt.style.fontSize = "20px";

            showAll();
            viewInfo();

        }

        function clickButton(index) {
            currentLine = index;

            if (index < 0) {
                showAll();
                info.remove();
                viewInfo();
            } else {
                clear()


                stroke(0, 200, 200);

                noFill();
                strokeWeight(2);
                //draw all thhe lines

                stroke(colors[index][0], colors[index][1], colors[index][2]);
                //draw the line
                beginShape();
                for (let i = 0; i < routes.lines[index].length; i++) {
                    vertex(...makeVisible(routes.lines[index][i]));
                    ellipse(...makeVisible(routes.lines[index][i]), 9);
                }
                endShape();

                //draw the stops
                stroke(255);
                strokeWeight(1);

                for (let i = 0; i < data.length; i++) {
                    let popularity = data[i].entrances + data[i].exits;
                    fill(map(popularity, 0, 30, 0, 255), map(popularity, 30, 300, 0, 255), map(popularity, 300,
                        3000, 0, 255));
                    ellipse(...makeVisible(data[i]), 6);
                }


                info.remove();
                viewInfo(index);
            }

        }


        function makeVisible(obj) {
            return [map(obj.x, graph.left, graph.right, 50, 750), map(obj.y, graph.upper, graph.lower, 50, 750)];
        }



        function viewInfo(index) {
            if (dropDown) {
                dropDown.remove()
                for (let i = 1; i < buttons.length; i++) {
                    buttons[i].remove();
                }
            }

            let validStops = data.filter(e => !e.name.includes("NOT A STOP"))
            let defaultText =
                `
            <h1 class = "title" >Explore a Bus System: <select id="chooseMap"></select></h1>
            <h3>${mapOptions[dropDown ? dropDown.value() : currentRoutesName].description}</h3>
            <p>Choose a bus line to learn more about it. Here are some overall statistics about this bus system:</p>
                <ul>
                <li>This bus system has a fitness score ${(routes.fitness/original.fitness * 100).toFixed(1)}% of the original bus system.</li>
                <li>This bus system has ${routes.lines.length} lines instead of the original ${original.lines.length}</li>
                <li>This bus system covers ${validStops.length - routes.info.missing} out of the ${validStops.length} original bus stops</li>
                <li>The stops overlap ${routes.info.overlap} times instead of the original ${original.info.overlap} times</li>
                <li>The lines travel a total of ${(routes.info.totalDist/1000).toFixed(1)}km, (${(routes.info.totalDist/1609.344).toFixed(1)}mi) about ${((original.info.totalDist - routes.info.totalDist)/1000).toFixed(1)}km (${((original.info.totalDist - routes.info.totalDist)/1609.344).toFixed(1)}mi) less than the original ${(original.info.totalDist/1000).toFixed(1)}km (${(original.info.totalDist/1609.344).toFixed(1)}mi)</li>
                </ul>
            `;
            if (index >= 0) {
                let stats = calcStats(index);
                let toggleText =
                    `
                <h1 class = "title" ><select id="chooseMap"></select>: Line ${index + 1}:</h1>
                <ul>
                <li>This line has ${routes.lines[index].length} stops</li>
                <li>This line covers ${(stats.dist/1000).toFixed(1)}km (${(stats.dist/1609.344).toFixed(1)}mi) </li>
                <li>On average, ${Math.round(stats.entrances)} people enter an inbound bus on this line on a weekday. </li>
                <li>This line connects with ${stats.shared.filter(e=>e.length).length} another lines for a total of ${stats.overlaps} overlaps</li>
                </ul>
                `;
                info = createDiv(toggleText);
            } else {
                info = createDiv(defaultText);
            }
            info.position(850, 400);

            dropDown = select('#chooseMap');

            for (let key of Object.keys(mapOptions)) {
                dropDown.option(key);
            }

            dropDown.selected(currentRoutesName);
            dropDown.style('font-size', '32px')
            dropDown.changed(selectMap);
            for (let i = 1; i < routes.lines.length + 1; i++) {
                buttons[i] = createButton("Line " + i, i)
                    .parent(container)
                    .addClass("line-button")
                    .mouseClicked(() => clickButton(i - 1));
                buttons[i].elt.style.backgroundColor = "rgb(" + colors[i - 1][0] + ", " + colors[i - 1][1] + ", " + colors[i - 1][2] + ")";
                buttons[i].elt.style.color = (colors[i - 1][0] * 299 + colors[i - 1][1] * 587 + colors[i - 1][2] * 114) / 1000 > 125 ? 'black' : 'white';
                buttons[i].elt.style.width = "70px";
            }
        }

        function showAll() {
            clear()
            stroke(0, 200, 200);
            noFill();

            strokeWeight(2);
            //draw all the lines
            for (let i = 0; i < routes.lines.length; i++) {
                if (i > colors.length - 1) { //add random colors if we need them
                    let r = round(random(50, 255));
                    let g = (r < 100) ? round(random(100, 255)) : round(random(50, 255));
                    let b = (r + g < 255) ? round(random(200, 255)) : round(random(50, 255));
                    colors.push([r, g, b]);
                }

                stroke(colors[i]);
                //draw the line
                beginShape();
                for (let j = 0; j < routes.lines[i].length; j++) {
                    vertex(...makeVisible(routes.lines[i][j]));
                }
                endShape();
            }

            //draw the stops
            stroke(255);
            strokeWeight(1);

            for (let i = 0; i < data.length; i++) {
                let popularity = data[i].entrances + data[i].exits;
                fill(map(popularity, 0, 30, 0, 255), map(popularity, 30, 300, 0, 255), map(popularity, 300, 3000, 0,
                    255));
                ellipse(...makeVisible(data[i]), 6);
            }
        }

        function calcStats(line) {

            let dist = 0;
            let entrances = 0;
            let exits = 0;
            let crowding = [];

            for (let i = 0; i < data.length; i++) {
                crowding[i] = 0;
            }

            for (let line of routes.lines) {
                for (let i = 0; i < line.length; i++) {
                    crowding[line[i].index]++;
                }
            }

            for (let i = 0; i < routes.lines[line].length; i++) {
                if (i < routes.lines[line].length - 1) {
                    dist += distances[routes.lines[line][i].index][routes.lines[line][i + 1].index];
                }

                entrances += routes.lines[line][i].entrances;
                exits += routes.lines[line][i].exits;

                let add = crowding[routes.lines[line][i].index];
            }

            let shared = routes.lines.map(e => {
                return stops = e.filter(stop => routes.lines[line].map(lineStop => lineStop.index).includes(stop.index))
            });
            shared = [...shared.slice(0, line), ...shared.slice(line + 1)]
            console.log(shared)

            let overlaps = shared.reduce((p, c) => p + c.length, 0)


            return {
                dist,
                entrances,
                exits,
                overlaps,
                shared
            };
        }

        function selectMap() {
            routes = mapOptions[dropDown.value()].routes;
            currentRoutesName = dropDown.value();
            clickButton(currentLine);

        }
    </script>
</body>

</html>