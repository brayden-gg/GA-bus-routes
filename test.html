<!DOCTYPE html>
<html>

<head>
  <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCfU_3YuXIiUyOmp3kULUueVTMmx7sqTGE&libraries=places"></script>
  <!-- <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/addons/p5.dom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/addons/p5.sound.min.js"></script>
  <script src="http://js.api.here.com/v3/3.0/mapsjs-core.js" type="text/javascript" charset="utf-8"></script>
  <script src="http://js.api.here.com/v3/3.0/mapsjs-service.js" type="text/javascript" charset="utf-8"></script>
  <meta name="viewport" content="initial-scale=1.0, width=device-width" />
  <meta charset="utf-8">
  <title>Test</title>
</head>

<body>
  <h1 id="text"></h1>
  <script src="riderData.js"></script>
  <script src="originalRoutes.js"></script>
  <script src="precalculatedDistances.js"></script>
  <script src="newDistances.js"></script>
  <script>
    let makeVisibleX;
    let makeVisibleY;
    let bestEver;
    let recordDist = Infinity;
    let lower = Infinity;
    let upper = -Infinity;
    let left = Infinity;
    let right = -Infinity;
    let mutationRate = .5;
    let ordersPerGen = 10;
    let generation = 1;
    let allOrders;
    let fitnesses = new Array();



    //var platform = new H.service.Platform({'app_id':'lf79PbooP7AFJqrPOS4h','app_code':'mk1drtPNjTt1l21yKXmW6g'});
    var setThisParam;

    function calculateRouteFromAtoB(platform, x1, y1, x2, y2) {
      //setThisParam = -1;
      var router = platform.getRoutingService(),
        routeRequestParams = {
          mode: 'fastest;car',
          representation: 'display',
          routeattributes: 'waypoints,summary,shape,legs',
          maneuverattributes: 'direction,action',
          waypoint0: x1 + ',' + y1,
          waypoint1: x2 + ',' + y2,
        };


      router.calculateRoute(
        routeRequestParams,
        function (result) {
          var route = result.response.route[0];
          setThisParam = route.summary.distance;

        },
        function (error) {
          alert('Ooops!');
        }
      );

    }

    //Step 1: initialize communication with the platform
    var platform = new H.service.Platform({
      app_id: 'DemoAppId01082013GAL',
      app_code: 'AJKnXv84fjrb0KIHawS0Tg',
      useCIT: true,
      useHTTPS: true
    });

    // let newDistances = [];
    // for (let i = 0; i < distances.length; i++) {
    //   newDistances[i] = [];
    // }













    function mutate(arr) { //mutate function

      for (let i = 0; i < arr.length; i++) {
        if (random(1) < mutationRate) { //swap this and last one
          let temp = arr[i];
          let rand = floor(random(arr.length));
          arr[i] = arr[rand];
          arr[rand] = temp;
        }

      }

    }

    function calcFitness(arr) { //fitness function
      let totalDist = 0;
      let totalPop = 0;
      for (let i = 0; i < arr.length; i++) {
        if (i < arr.length - 1) {
          totalDist += distances[arr[i].index][arr[i + 1].index]; //dist(arr[i].x, arr[i].y, arr[i + 1].x, arr[i + 1].y);
        }
        totalPop += arr[i].entrances + arr[i].exits;
      }

      return -totalDist; // * 5 + arr.length * 2 + totalPop / (arr.length * 3);

    }



    //----SETUP----
    function setup() {
      createCanvas(800, 800);
      ellipseMode(CENTER);

      allOrders = new Array();

      for (let i = 0; i < ordersPerGen; i++) { //create the orders
        let possibleChoices = data.slice();
        allOrders[i] = new Object();
        allOrders[i].places = new Array();
        for (let j = 0; j < data.length; j++) { //randomize stops
          let chosenRand = floor(random(possibleChoices.length));
          allOrders[i].places[j] = possibleChoices.splice(chosenRand, 1)[0];
          allOrders[i].fitness = 0;

        }
        bestEver = Object.assign({}, allOrders[i]);

      }


      //put this whenever you want to display an x or y
      makeVisibleX = (a) => map(a, left, right, 50, 750);
      makeVisibleY = (a) => map(a, upper, lower, 50, 750);


      for (let i = 0; i < data.length; i++) { //set boundaries for the displaying of the map
        if (data[i].x < left) left = data[i].x;
        if (data[i].x > right) right = data[i].x;
        if (data[i].y < lower) lower = data[i].y;
        if (data[i].y > upper) upper = data[i].y;
      }
      noLoop();
    }

    //-----DRAW----//

    function draw() {
      background(0);
      noFill();

      //mutate and calculate fitness

      let totalFitness = 0;
      let fitness = [];
      for (let i = 0; i < allOrders.length; i++) {
        allOrders[i].places = bestEver.places.slice(); //pickOne(allOrders;
        if (i >= 1) {
          mutate(allOrders[i].places);
        }
        fitness[i] = calcFitness(allOrders[i].places);

      }
      for (let i = 0; i < allOrders.length; i++) {
        totalFitness += fitness[i];
      }


      for (let i = 0; i < allOrders.length; i++) {

        allOrders[i].fitness = fitness[i]; //(totalFitness + 1);
        if (allOrders[i].fitness > Math.max(...fitnesses)) {
          bestEver = Object.assign({}, allOrders[i]);


          fitnesses.push(bestEver.fitness);
          if (fitnesses.length > 100) {
            fitnesses.shift();
          }
        }


      }
      if (bestEver.fitness < Math.max(...fitnesses)) {
        console.log(bestEver.fitness + ' < ' + Math.max(...fitnesses));
        console.log(fitnesses);
        noLoop();

      }
      //draw current best
      stroke(0, 200, 200);
      strokeWeight(2);

      beginShape();
      for (let i = 0; i < bestEver.places.length; i++) {
        vertex(makeVisibleX(bestEver.places[i].x), makeVisibleY(bestEver.places[i].y));
      }
      endShape();

      for (let i = 0; i < data.length; i++) {
        let popularity = data[i].entrances + data[i].exits;
        fill(map(popularity, 0, 30, 0, 255), map(popularity, 30, 300, 0, 255), map(popularity, 300, 3000, 0, 255));
        ellipse(makeVisibleX(data[i].x), makeVisibleY(data[i].y), 6); //popularity < 30 ? 2 : popularity < 300 ? 4 : popularity < 3000 ? 8 : 16);
        ellipse(makeVisibleX(data[i].x) + 800, makeVisibleY(data[i].y), 6);
      }

      document.getElementById('text').innerHTML = "Generation " + generation + ", Fitness: " + bestEver.fitness +
        ", Score to beat: " + calcFitness(data); // * totalFitness;
      generation++;


    }



    //FIX: 8, 300  , 257 , 258 , 216 , 255 , 6

    // let stops = [];
    // let dups = [];
    // let bad = [];

    // for (let i = 0; i < data.length; i++) {

    //   if (stops.includes(data[i].x)) {
    //     dups.push(i);
    //     dups.push(stops.indexOf(data[i].x));
    //     console.log(i === stops.indexOf(data[i].x))
    //   }

    //   stops.push(data[i].x);



    // }

    // for (let elt of dups) {
    //   if (toBeFixed.includes(elt) && !bad.includes(elt)) {
    //     console.log(data[elt]);
    //     bad.push(data[elt].index);
    //   }

    // }
    let outer = 0;
    let inner = 0;
    let toBeFixed = [4];


    function fixThemAll() {
      let index;
      let temp = setThisParam;



      if (toBeFixed.includes(outer)) {
        if (inner >= data.length) {
          inner = 0;
          outer++;
        }
      } else {
        if (inner >= toBeFixed.length) {
          inner = 0;
          outer++;
        }
        
      }

      if (toBeFixed.includes(outer)) {
        index = inner;
      } else {
        index = toBeFixed[inner];
      }



      
        if (inner == 200 || outer == 200) {
          distances[outer][index] = "Infinity";
          console.log(distances[outer][index], outer, index);


        } else {

          calculateRouteFromAtoB(platform, data[outer].y, data[outer].x, data[index].y, data[index].x);
          setTimeout(() => {
            if(setThisParam == temp){
              distances[outer][index] = NaN;
            }else{
              distances[outer][index] = setThisParam;
            }
            console.log(distances[outer][index], outer, index);

          }, 100);

        }
        inner++;
      

    }

    function fixNaNs() {
      let temp = setThisParam;



        if (inner >= data.length) {
          inner = 0;
          outer++;
        }

        while(!distances[outer].includes(null)){
          outer++;
        }

        inner = distances[outer].indexOf(null);
      
        if (inner == 200 || outer == 200) {
          distances[outer][inner] = "Infinity";
          //console.log(distances[outer][inner], outer, inner);
          inner++;
          fixNaNs();


        } else {

          calculateRouteFromAtoB(platform, data[outer].y, data[outer].x, data[inner].y, data[inner].x);
          setTimeout(() => {
            if(setThisParam == temp){
              distances[outer][inner] = NaN;
            }else{
              distances[outer][inner] = setThisParam;
            }
            console.log(distances[outer][inner], outer, inner);
            inner++;

          }, 300);

        }
       
      

    }



    let inter = setInterval(fixNaNs, 500);
    // let dLen = [];
    // for (let i = 0; i < distances.length; i++) {
    //   if (distances[i].length !== 333) dLen[i] = distances[i].length;
    // }


    // key: 
    //AIzaSyCfU_3YuXIiUyOmp3kULUueVTMmx7sqTGE
    //https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=AIzaSyCfU_3YuXIiUyOmp3kULUueVTMmx7sqTGE
  </script>
</body>

</html>